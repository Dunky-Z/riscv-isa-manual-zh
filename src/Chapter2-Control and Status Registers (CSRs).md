# Control and Status Registers (CSRs)

RISC-V ISA 中，SYSTEM 主操作码用于编码所有特权指令。这些指令可以分为两类：一类是原子地读取 - 修改 - 写入控制和状态寄存器（CSRs），这些寄存器在 Zicsr 扩展中定义；另一类是其他所有特权指令。特权架构要求使用 Zicsr 扩展，而其他所需的特权指令取决于特权架构的功能集。

除了本手册第一卷中描述的非特权状态之外，实现可能包含附加的控制和状态寄存器 (CSRs)，这些 CSR 可以通过本手册第一卷中描述的 CSR 指令由某些特权级的子集访问。在本章中，我们将映射 CSR 地址空间。接下来的章节将根据特权级别描述每个 CSR 的功能，以及通常与特定特权级别密切相关的其他特权指令。请注意，尽管 CSR 和指令与一个特权级别相关联，但它们也可以在所有更高的特权级别上访问。

标准 CSR 在读取时没有副作用，但在写入时可能有副作用。

## CSR 地址映射约定

RISC-V ISA 标准为最多 4,096 个 CSR 分配了一个 12 位编码空间（csr[11:0]）。按照惯例，CSR 地址的高 4 位（csr[11:8]）用于根据特权级别编码 CSR 的读取和写入可访问性，如表 2.1 所示。最高的两位（csr[11:10]）表示寄存器是读/写（00、01 或 10）还是只读（11）。接下来的两位（csr[9:8]）编码了可以访问 CSR 的最低特权级别。


> CSR 地址约定使用 CSR 地址的高位来编码默认访问权限。这简化了硬件中的错误检查，并提供了更大的 CSR 空间，但它限制了 CSR 映射到地址空间的方式。实现可能允许更高权限级别捕获否则允许的低权限级别的 CSR 访问，以便拦截这些访问。这种改变对低权限软件来说应该是透明的。

尝试访问不存在的 CSR 会引发非法指令异常。尝试在没有适当特权级别的情况下访问 CSR 或写入只读寄存器也会引发非法指令异常。读/写寄存器可能还包含一些只读位，这种情况下对只读位的写入将被忽略。

表 2.1 还指示了将 CSR 地址分配给标准和自定义用途的约定。指定用于自定义用途的 CSR 地址将不会被未来的标准扩展重新定义。

机器模式标准读/写CSR 0x7A0–0x7BF 被保留供调试系统使用。其中，0x7A0–0x7AF 可由机器模式访问，而 0x7B0–0x7BF 仅对调试模式可见。实现应在机器模式访问后一组寄存器时引发非法指令异常。

> 有效的虚拟化需要尽可能多的指令在虚拟化环境内本地运行，而任何特权访问都会被陷阱到虚拟机监视器[1]。如果某些低特权级别下只读的 CSRs 在更高特权级别下变为可读写，则它们会被映射到单独的 CSR 地址中。这样可以避免捕获允许的低特权级别访问，同时仍然会对非法访问进行陷阱处理。目前，计数器是唯一被映射的 CSRs。
> 
> 译者注：
> 1. 为什么需要指令更多地在虚拟化环境内本地运行？
因为指令在虚拟化环境内本地运行可以提高虚拟机的性能，减少虚拟机监视器的介入，从而使虚拟机更加高效地运行。
> 2. 为什么可以避免捕获允许的低特权级别访问？
因为在虚拟化环境内，低特权级别的访问可能会对虚拟机造成安全威胁，所以需要将这些访问陷阱到虚拟机监视器中进行处理。而将只读的 CSR 映射到单独的 CSR 地址中，可以避免捕获允许的低特权级别访问，同时仍然会对非法访问进行陷阱处理，从而保证虚拟机的安全性。
> 3. 为什么计数器是唯一被映射的 CSRs？
因为计数器是虚拟机中比较重要的部分，需要在虚拟化环境中进行监控和管理，所以计数器是唯一被映射的 CSR。其他的 CSR 可以通过陷阱到虚拟机监视器中进行处理，而不需要映射到单独的 CSR 地址中。


2.2 CSR 列表

表格 2.2-2.6 列出了当前已分配 CSR 地址的 CSR。定时器、计数器和浮点 CSR 是标准的非特权级 CSR。其他寄存器由特权代码使用，如下一章节所述。请注意，并非所有寄存器都需要在所有实现中使用。


![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/f5ee06fe22319ed92a7590d5740f5b03.png)

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/68fb2cb9db6cfd9c83a9c72cb73b5000.png)

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/3fa47d268c7b721d6019a7786d553121.png)

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/751f5e8e53e5e85aadfb955dc4728da2.png)

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/316c0960fa866618cf52e1446b8d51a4.png)

## CSR 域规范

在规定 CSR 字段行为时，以下定义和缩写被使用。

### 保留写保留值，读取忽略值（WPRI）

一些整个读/写字段被保留以备将来使用。软件应忽略从这些字段读取的值，并且在将值写入同一寄存器的其他字段时应保留这些字段中保存的值。为了向前兼容，不提供这些字段的实现必须将它们设置为只读零。这些字段在寄存器描述中标记为 WPRI。

> 为了简化软件模型，CSR 中先前保留字段的任何向后兼容的未来定义都必须应对在更新 CSR 中的其他字段时使用非原子读取/修改/写入序列的可能性。或者，原始的CSR定义必须指定子字段只能以原子方式更新，这可能需要一般情况下的两个指令清除位/设置位序列，如果中间值不合法，则可能会出现问题。


### 只写/只读合法值（WLRL） 

一些读/写CSR字段仅指定可能位编码的子集的行为，而保留其他位编码。软件不应向此类字段写入任何非法值，并且不应假定读取将返回合法值，除非上次写入是合法值，或者自从另一个操作（例如重置）将寄存器设置为合法值以来，寄存器尚未被写入。这些字段在寄存器描述中标记为WLRL。

> 硬件实现只需要实现足够的状态位来区分支持的值，但必须始终在读取时返回任何支持值的完整指定位编码。


### 写任何值，读任何合法值 (WARL) 

指的是某些读/写 CSR 字段仅适用于一部分位编码，但允许写入任何值，并保证在读取时返回合法值。假设写入 CSR 没有其他副作用，可以通过尝试写入所需设置并读取以查看该值是否保留来确定支持的值范围。这些字段在寄存器描述中标记为 WARL。在 WARL 字段中写入不受支持的值时，实现不会引发异常。当最后一次写入是非法值时，实现可以在 WARL 字段的读取时返回任何合法值，但返回的合法值应该确定地取决于非法写入值和 hart 的架构状态。



### 机器 Trap 委托寄存器 (medeleg and mideleg)

默认情况下，任何特权级别的所有 Trap 都在机器模式下处理，尽管机器模式处理程序可以使用 MRET 指令（第 3.3.2 节）将 Trap 重定向回适当的级别。

为了提高性能，实现可以在 `medeleg` 和 `mideleg` 中提供单独的读/写位，以指示某些异常和中断应由较低的特权级别直接处理。机器异常委托寄存器（machine exception delegation register,medeleg）和机器中断委托寄存器（machine interrupt
delegation register, mideleg）为 MXLEN 位读写寄存器。

在具有 S-mode 的系统中，`medeleg` 和 `mideleg` 寄存器必须存在，并且在 medeleg 或 mideleg 中设置一个位将在 S-mode 或 U-mode 中发生时将相应的 Trap 委托给 S-mode Trap 处理程序。在没有 S-mode 的系统中，`medeleg` 和 `mideleg` 寄存器不应该存在。

> 在 1.9.1 及更早的版本中，这些寄存器存在但仅在 M 模式或没有 N 系统的 M/U 中硬接线为零。在这些情况下没有理由要求它们返回零，因为 `misa` 寄存器指示它们是否存在。

当 Trap 委托给 S 模式时，将 Trap 原因写入 `scause` 寄存器；`sepc` 寄存器写入捕获 Trap 的指令的虚拟地址；`stval` 寄存器写入异常特定数据；`mstatus` 的 `SPP` 字段写入 trap 时的 active 特权模式；`mstatus` 的 `SPIE` 字段写入 trap 时 `SIE` 字段的值；`mstatus` 的 `SIE` 字段被清除。`mcause`、`mepc` 和 `mtval` 寄存器以及 `mstatus` 的 `MPP` 和 `MPIE` 字段没有写入。

实现可以选择对可委托 Trap 进行子集化，通过向每个位位置写入 `1` 找到支持的可委托位，然后读回 `medeleg` 或 `mideleg` 中的值以查看哪些位位置为 1。

一个实现不应有任何 `medeleg` 位是只读的，即，任何可以委托的同步 Trap 必须支持不被委托。类似地，一个实现不应将对应于机器级中断的 `mideleg` 的任何位固定为只读（但可以为较低级别的中断这样做）。

> 1.11 版及更早版本禁止将 `mideleg` 的任何位设为只读。平台标准可能总是添加此类限制。

Trap 永远不会从特权更高的模式转换到特权更低的模式。例如，如果 M-mode 已将非法指令异常委托给 S-mode，并且 M-mode 软件随后执行了一条非法指令，则 Trap 将在 M-mode 中捕获，而不是委托给 S-mode。相比之下，Trap 可以水平放置。使用相同的示例，如果 M 模式已将非法指令异常委托给 S 模式，并且 S 模式软件稍后执行非法指令，则 Trap 在 S 模式中发生。

委托中断导致中断在委托者特权级别被屏蔽。例如，如果通过设置 `mideleg[5]` 将监控定时器中断 (STI) 委托给 S 模式，则在 M 模式下执行时不会采用 `STI`。相比之下，如果 `mideleg[5]` 清晰，则可以在任何模式下进行 STI，并且无论当前模式如何，都会将控制权转移到 M 模式。

![机器异常委托寄存器 `medeleg`](../pic/Pic-3-10.jpg "机器异常委托寄存器`medeleg`")

`medeleg` 为第 39 页表 3.6 中所示的每个同步异常分配了一个位位置，位位置的索引等于 `mcause` 寄存器中返回的值（即，设置位 8 允许将用户模式环境调用委托给较低权限的 Trap 处理程序）。

![机器中断委托寄存器 mideleg](../pic/Pic-3-11.jpg "机器中断委托寄存器mideleg")

`mideleg` 保存各个中断的 Trap 委托位，位布局与 `mip` 寄存器中的位布局相匹配（即，`STIP` 中断委托控制位于位 5）。对于不能在低特权模式下发生的异常，相应的 `medeleg` 位应该是只读的零。特别是，`medeleg[11]` 是只读零。