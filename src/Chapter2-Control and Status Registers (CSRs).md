# Control and Status Registers (CSRs)

RISC-V ISA 中，SYSTEM 主操作码用于编码所有特权指令。这些指令可以分为两类：一类是原子地读取 - 修改 - 写入控制和状态寄存器（CSRs），这些寄存器在 Zicsr 扩展中定义；另一类是其他所有特权指令。特权架构要求使用 Zicsr 扩展，而其他所需的特权指令取决于特权架构的功能集。

除了本手册第一卷中描述的非特权状态之外，实现可能包含附加的控制和状态寄存器 (CSRs)，这些 CSR 可以通过本手册第一卷中描述的 CSR 指令由某些特权级的子集访问。在本章中，我们将映射 CSR 地址空间。接下来的章节将根据特权级别描述每个 CSR 的功能，以及通常与特定特权级别密切相关的其他特权指令。请注意，尽管 CSR 和指令与一个特权级别相关联，但它们也可以在所有更高的特权级别上访问。

标准 CSR 在读取时没有副作用，但在写入时可能有副作用。

## CSR 地址映射约定

RISC-V ISA 标准为最多 4,096 个 CSR 分配了一个 12 位编码空间（csr[11:0]）。按照惯例，CSR 地址的高 4 位（csr[11:8]）用于根据特权级别编码 CSR 的读取和写入可访问性，如表 2.1 所示。最高的两位（csr[11:10]）表示寄存器是读/写（00、01 或 10）还是只读（11）。接下来的两位（csr[9:8]）编码了可以访问 CSR 的最低特权级别。

> CSR 地址约定使用 CSR 地址的高位来编码默认访问权限。这简化了硬件中的错误检查，并提供了更大的 CSR 空间，但它限制了 CSR 映射到地址空间的方式。实现可能允许更高权限级别捕获否则允许的低权限级别的 CSR 访问，以便拦截这些访问。这种改变对低权限软件来说应该是透明的。

尝试访问不存在的 CSR 会引发非法指令异常。尝试在没有适当特权级别的情况下访问 CSR 或写入只读寄存器也会引发非法指令异常。读/写寄存器可能还包含一些只读位，这种情况下对只读位的写入将被忽略。

表 2.1 还指示了将 CSR 地址分配给标准和自定义用途的约定。指定用于自定义用途的 CSR 地址将不会被未来的标准扩展重新定义。

机器模式标准读/写CSR 0x7A0–0x7BF 被保留供调试系统使用。其中，0x7A0–0x7AF 可由机器模式访问，而 0x7B0–0x7BF 仅对调试模式可见。实现应在机器模式访问后一组寄存器时引发非法指令异常。

> 有效的虚拟化需要尽可能多的指令在虚拟化环境内本地运行，而任何特权访问都会被陷阱到虚拟机监视器 [1]。如果某些低特权级别下只读的 CSRs 在更高特权级别下变为可读写，则它们会被映射到单独的 CSR 地址中。这样可以避免捕获允许的低特权级别访问，同时仍然会对非法访问进行陷阱处理。目前，计数器是唯一被映射的 CSRs。
>
> 译者注：
>
> 1. 为什么需要指令更多地在虚拟化环境内本地运行？
因为指令在虚拟化环境内本地运行可以提高虚拟机的性能，减少虚拟机监视器的介入，从而使虚拟机更加高效地运行。
> 2. 为什么可以避免捕获允许的低特权级别访问？
因为在虚拟化环境内，低特权级别的访问可能会对虚拟机造成安全威胁，所以需要将这些访问陷阱到虚拟机监视器中进行处理。而将只读的 CSR 映射到单独的 CSR 地址中，可以避免捕获允许的低特权级别访问，同时仍然会对非法访问进行陷阱处理，从而保证虚拟机的安全性。
> 3. 为什么计数器是唯一被映射的 CSRs？
因为计数器是虚拟机中比较重要的部分，需要在虚拟化环境中进行监控和管理，所以计数器是唯一被映射的 CSR。其他的 CSR 可以通过陷阱到虚拟机监视器中进行处理，而不需要映射到单独的 CSR 地址中。

2.2 CSR 列表

表格 2.2-2.6 列出了当前已分配 CSR 地址的 CSR。定时器、计数器和浮点 CSR 是标准的非特权级 CSR。其他寄存器由特权代码使用，如下一章节所述。请注意，并非所有寄存器都需要在所有实现中使用。

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/f5ee06fe22319ed92a7590d5740f5b03.png)

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/68fb2cb9db6cfd9c83a9c72cb73b5000.png)

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/3fa47d268c7b721d6019a7786d553121.png)

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/751f5e8e53e5e85aadfb955dc4728da2.png)

![](https://picbed-1311007548.cos.ap-shanghai.myqcloud.com/markdown_picbed/img//2023/03/23/316c0960fa866618cf52e1446b8d51a4.png)

## CSR 域规范

在规定 CSR 字段行为时，以下定义和缩写被使用。

### 保留写保留值，读取忽略值（WPRI）

一些整个读/写字段被保留以备将来使用。软件应忽略从这些字段读取的值，并且在将值写入同一寄存器的其他字段时应保留这些字段中保存的值。为了向前兼容，不提供这些字段的实现必须将它们设置为只读零。这些字段在寄存器描述中标记为 WPRI。

> 为了简化软件模型，CSR 中先前保留字段的任何向后兼容的未来定义都必须应对在更新 CSR 中的其他字段时使用非原子读取/修改/写入序列的可能性。或者，原始的CSR定义必须指定子字段只能以原子方式更新，这可能需要一般情况下的两个指令清除位/设置位序列，如果中间值不合法，则可能会出现问题。

### 只写/只读合法值（WLRL）

一些读/写CSR字段仅指定可能位编码的子集的行为，而保留其他位编码。软件不应向此类字段写入任何非法值，并且不应假定读取将返回合法值，除非上次写入是合法值，或者自从另一个操作（例如重置）将寄存器设置为合法值以来，寄存器尚未被写入。这些字段在寄存器描述中标记为WLRL。

> 硬件实现只需要实现足够的状态位来区分支持的值，但必须始终在读取时返回任何支持值的完整指定位编码。

### 写任何值，读任何合法值 (WARL)

指的是某些读/写 CSR 字段仅适用于一部分位编码，但允许写入任何值，并保证在读取时返回合法值。假设写入 CSR 没有其他副作用，可以通过尝试写入所需设置并读取以查看该值是否保留来确定支持的值范围。这些字段在寄存器描述中标记为 WARL。在 WARL 字段中写入不受支持的值时，实现不会引发异常。当最后一次写入是非法值时，实现可以在 WARL 字段的读取时返回任何合法值，但返回的合法值应该确定地取决于非法写入值和 hart 的架构状态。

## CSR 字段调制

如果向一个 CSR 的写入更改了第二个 CSR 的字段的合法值集合，则除非另有说明，第二个 CSR 的字段将立即从其新的合法值中获得一个未指定的值。即使在写入之前，该字段的值仍然是合法的，也是如此；由于对控制 CSR 的写入，该字段的值可能会发生变化。

> 作为这个规则的一个特例，写入一个 CSR 的值可以控制第二个 CSR 的一个字段是可写的（有多个合法值）还是只读的。当写入控制 CSR 时，导致第二个 CSR 的字段从之前的只读状态变为现在可写时，该字段立即获得一个未指定但合法的值，除非另有规定。

> 当某些 CSR 字段可写时，它们被定义为其他 CSR 字段的别名。设 x 是这样一个 CSR 字段，y 是它在可写时所别名的 CSR 字段。如果对控制 CSR 的写入导致字段 x 从之前的只读状态变为现在可写，那么 x 的新值不是未指定的，而是立即反映其别名 y 的现有值，正如所需的那样。

由于这个原因对 CSR 值的更改不是对受影响的 CSR 的写入，因此不会触发为该 CSR 指定的任何副作用。

### CSR 隐式读

实现有时会执行 CSR 的隐式读取操作。（例如，所有 S 模式指令获取都会隐式读取 `satp` CSR。）除非另有规定，否则通过隐式读取 CSR 返回的值与使用足够特权模式下的 CSR 访问指令显式读取 CSR 所返回的值相同。

### CSR 宽度调制

如果改变 CSR 的宽度（例如通过改变 MXLEN 或 UXLEN，如 3.1.6.2 节所述），则除非另有规定，新宽度 CSR 的可写字段和位的值是根据以下算法从旧宽度 CSR 确定的：

- 将旧宽度 CSR 的值复制到同一宽度的临时寄存器中。
- 对于旧宽度 CSR 的只读位，设置临时寄存器中相同位置的位为 0。
- 临时寄存器的宽度更改为新宽度。如果新宽度 W 比以前的宽度窄，则保留临时寄存器的最低有效 W 位，高位位将被丢弃。如果新宽度比以前的宽度更宽，则将临时寄存器进行零扩展以匹配更宽的宽度。
- 新宽度 CSR 的每个可写字段都采用临时寄存器中相同位置的位的值。

改变 CSR 的宽度不是对 CSR 的读取或写入，因此不会触发任何副作用。